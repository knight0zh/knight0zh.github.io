<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Flutter on 超级浩码</title>
    <link>https://vastzh.com/tags/flutter/</link>
    <description>Recent content in Flutter on 超级浩码</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© 2024 超级浩码</copyright>
    <lastBuildDate>Wed, 14 Aug 2024 11:25:00 +0800</lastBuildDate><atom:link href="https://vastzh.com/tags/flutter/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Google Play Android 14 还没有升级将导致下架2024</title>
      <link>https://vastzh.com/blog/android14/</link>
      <pubDate>Wed, 14 Aug 2024 11:25:00 +0800</pubDate>
      
      <guid>https://vastzh.com/blog/android14/</guid>
      <description>&lt;div id=&#34;前言&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;前言 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%89%8d%e8%a8%80&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;在今年的6月，Google Play 已经宣布了 Android 14 的强制升级，最晚期限是 2024 年 8 月 31 日。原文地址：&lt;a href=&#34;https://support.google.com/googleplay/android-developer/answer/11926878?hl=zh-Hans&#34;   target=&#34;_blank&#34;&gt;
    https://support.google.com/googleplay/android-developer/answer/11926878?hl=zh-Hans&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自 2024 年 8 月 31 日起：
新应用和应用更新必须以 Android 14（API 级别 34）为目标平台，才能提交到 Google Play（Wear OS 应用和 Android TV 应用除外，此类应用必须以 Android 13 或更高版本为目标平台）。
现有应用必须以 Android 13（API 级别 33）或更高版本为目标平台，Google Play 才会在新用户的设备搭载的 Android OS 版本高于应用的目标 API 级别时，继续向这些用户提供此类应用。如果应用以 Android 12（API 级别 31）或更低版本（如果是 Wear OS 应用，则为 Android 10 或更低版本；如果是 TV OS 应用，则为 Android 11 或更低版本）为目标平台，则只能在搭载的 Android OS 版本不高于应用的目标 API 级别的设备上使用。
如果您需要更多时间来更新应用，可申请延期至 2024 年 11 月 1 日。今年晚些时候，您将能够在 Play 管理中心内找到应用的延期表单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果逾期未升级，将导致应用被下架。&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/android14/image.png&#34;
        alt=&#34;alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;div id=&#34;解决方案&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;解决方案 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;div id=&#34;延期&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h3 class=&#34;relative group&#34;&gt;延期 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%bb%b6%e6%9c%9f&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h3&gt;
&lt;p&gt;如果时间比较仓促也可以选择延期，最晚可延期至2024年11月1日之前。&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/android14/image-4.png&#34;
        alt=&#34;alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;div id=&#34;升级&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h3 class=&#34;relative group&#34;&gt;升级 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%8d%87%e7%ba%a7&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h3&gt;
&lt;p&gt;升级的方法其实比较简单。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;检查Android SDK的版本，可以通过Android Studio的SDK Manager查看。并进行升级。





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/android14/image-1.png&#34;
        alt=&#34;alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;在项目的android/app目录下，找到build.gradle文件，在android节点下更新如下代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;android {
    compileSdkVersion 34
    ...
    defaultConfig {
        minSdkVersion 34
        targetSdkVersion 34
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后重新编译，上传到Google Play，等待审核即可。&lt;/br&gt;
如果你的Flutter项目，没有依赖其他的插件，那么这个问题应该已经得到了解决。&lt;/p&gt;
&lt;p&gt;当你觉得一切都很顺利的时候，往往就会出现这样那样的问题。





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/android14/image-2.png&#34;
        alt=&#34;alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;明明已经将&lt;code&gt;compileSdkVersion&lt;/code&gt;,&lt;code&gt;targetSdkVersion&lt;/code&gt;,&lt;code&gt;minSdkVersion&lt;/code&gt;都更新到34了，为什么还会出现这个问题呢？&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;事实上，在多数的项目中我们都会依赖一些插件，其中有些插件使用了com.google.android.play:core的降低版本，这个版本有可能与Android 14 产生冲突。必须把他们升级到兼容Android 14的版本。&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;那么问题来了，依赖的插件少则十几种多则几十种，应该如何快速定位到这些插件库，依赖了com.google.android.play:core呢？&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;我们可以根据应用需求将整体 SDK 拆分为所需的依赖项。可&lt;a href=&#34;https://developer.android.com/reference/com/google/android/play/core/release-notes#partitioned-apis&#34;   target=&#34;_blank&#34;&gt;
    在此处&lt;/a&gt;  &lt;code&gt;play-core&lt;/code&gt;找到替代 SDK。而对于我使用的Flutter混合应用程序，我们可以进入android文件夹。
&lt;/br&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;运行以下命令检查应用程序中列出的所有依赖项，并com.google.android.play:core通过将所有依赖项导出到文本文件来检查哪一个具有依赖项dependencies.txt&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;./gradlew app:dependencies &amp;gt; dependencies.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一旦弄清楚了哪些依赖项使用了Play核心库，就可以将其更新了。
我们往往会关注&lt;strong&gt;支付，广告，权限等&lt;/strong&gt;核心库。而忽略一些看起来不那么重要的存在。





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/android14/image-3.png&#34;
        alt=&#34;alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;之后我们更新对应依赖到支持Android 14的版本，重新编译，上传到Google Play，等待审核即可。&lt;/p&gt;
&lt;div id=&#34;小结&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;小结 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%b0%8f%e7%bb%93&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;Google Play 于 2024 年 8 月 31 日起正式实施新的应用程序目标平台要求:所有新发布和更新的应用必须以 Android 14（API 级别 34）或更高版本为目标平台。现有应用也需尽快升级至 Android 13 或更高版本。这一举措旨在提升用户体验,增强应用程序的安全性和兼容性。开发者可申请延期至 2024 年 11 月 1 日完成升级,届时 Google Play 将提供相关表单。开发者务必及时关注并响应这一新政策,以确保应用程序在 Google Play 上的持续可用性。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;感谢阅读本文
如果有什么建议，请在评论中让我知道。我很乐意改进。





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/img/wc-search.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>开发日记 —— 记录对接苹果微信登录的坑</title>
      <link>https://vastzh.com/blog/wechat_login/</link>
      <pubDate>Mon, 29 Jan 2024 09:38:15 +0800</pubDate>
      
      <guid>https://vastzh.com/blog/wechat_login/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在对接iOS微信登录时，踩了不少坑，查了很多网上的资料但是对&lt;strong&gt;Universal Links&lt;/strong&gt;和&lt;strong&gt;Associated Domains&lt;/strong&gt;的配置都比较模糊，本文详细介绍怎么配置这些参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div id=&#34;配置开放平台&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;配置开放平台 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e9%85%8d%e7%bd%ae%e5%bc%80%e6%94%be%e5%b9%b3%e5%8f%b0&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;如果你的应用需要使接入微信生态相关功能，如&lt;strong&gt;微信登录、微信支付、微信分享&lt;/strong&gt;等，那就需要先在微信开放平台注册账号。&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/wechat_login/image.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;完成做&lt;strong&gt;开发者资质认证&lt;/strong&gt;，认证通过后，就可以进行&lt;strong&gt;应用接入&lt;/strong&gt;。需要注意认证的费用为300元，提交后会有微信交托的三方认证公司给你来电确认信息，所以看到陌生电话不要直接拒接。&lt;/p&gt;
&lt;p&gt;完成上述认证后进入正题开始接入&lt;strong&gt;微信登录&lt;/strong&gt;。在开放平台管理中心&lt;code&gt;创建移动应用&lt;/code&gt;(开发者资质可以创建50个)，填写应用名称、包名等基本信息。点击&lt;code&gt;下一步&lt;/code&gt;





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/wechat_login/image-1.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;这里需要注意&lt;strong&gt;Universal Links&lt;/strong&gt;的填写。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Universal Links&lt;/strong&gt; 是苹果在 WWDC 上提出的 iOS9 的新特性之一。此特性类似于深层链接，并能够方便地通过打开一个 Https 链接来直接启动您的客户端应用(手机有安装 App)。对比起以往所使用的 URL Scheme,这种新特性在实现 web-app 的无缝链接时能够提供极佳的用户体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单说这个链接就是用来打开你应用的入口，在微信中点击这个链接，就会直接跳转到你的应用。
配置成功后可以尝试在手机Safari浏览器直接访问该地址会显示&lt;strong&gt;打开&lt;/strong&gt;按钮。





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/wechat_login/image-2.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;hr&gt;
&lt;div id=&#34;配置xcode&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;配置Xcode 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e9%85%8d%e7%bd%aexcode&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;此外我们还需要在Xcode中配置&lt;strong&gt;Associated Domains&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;Sigining &amp;amp; Capabilities&lt;/code&gt; -&amp;gt; &lt;code&gt;Associated Domains&lt;/code&gt; -&amp;gt; &lt;code&gt;+&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接着在下方&lt;strong&gt;Domais&lt;/strong&gt;中填写&lt;code&gt;applinks:xxx.com&lt;/code&gt;，其中xxx.com是你的域名。





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/wechat_login/image-4.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  


这里的域名需要和Universal Links中的域名一致，例如：&lt;/p&gt;
&lt;p&gt;开放平台设置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Universal Links&lt;/strong&gt;: &lt;code&gt;https://xxx.com/st/universal_link/wechat/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Xcode&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Domais&lt;/strong&gt;: &lt;code&gt;applinks:xxx.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置文件下载地址
&lt;code&gt;https://xxx.com/.well-known/apple-app-site-association&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;.well-known 目录是一个由互联网工程任务组（IETF）在RFC 5785中定义的特殊目录，用于存放网站的一些特定的元数据或者配置文件。这个目录通常放在网站的根目录下，使得这些配置文件可以通过一个标准和一致的方式被访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;APP会在第一次启动的时候通过填写的域名来下载apple-app-site-association文件。
所以我们还需要在服务器对应地址下放一个apple-app-site-association的json文件，内容如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
  &amp;#34;applinks&amp;#34;: {
    &amp;#34;apps&amp;#34;: [],
    &amp;#34;details&amp;#34;: [
      {
        &amp;#34;appID&amp;#34;: &amp;#34;${your team id}.${your app bundle id}&amp;#34;,
        &amp;#34;paths&amp;#34;: [
          &amp;#34;/universal_link/wechat/*&amp;#34;   //开放平台中的Universal Links Uri对应
        ]
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;div id=&#34;客户端&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;客户端 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%ae%a2%e6%88%b7%e7%ab%af&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;这里只简单介绍下客户端集成不是本文重点。插件可以使用fluwx 或 wechat_kit。以fluwx为例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    await fluwx
        .authBy(
            which: NormalAuth(
          scope: &amp;#39;snsapi_userinfo&amp;#39;,
          state: &amp;#39;wechat_sdk_demo_test&amp;#39;,
        ))
        .then((value) async {});


    fluwx.addSubscriber((response) async {
      if (response is WeChatAuthResponse) {
        await getWeChatAccessToken(response.code);
        await getUserData();
        Get.back();
      }
    });    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;插件主要是完成&lt;strong&gt;APP-&amp;gt;微信-&amp;gt;APP&lt;/strong&gt;的跳转工作，通过回调拿到code。但不是最终我们需要的openid。接着再通过接口获取openid和access_token。
详细可参考文档：
&lt;code&gt;https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;access_token：通过code换取access_token和openid&lt;/li&gt;
&lt;li&gt;userinfo：获取微信用户基本信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里需要注意，如果你在开放平台配置的&lt;strong&gt;Universal Links&lt;/strong&gt;的不能返回200。或者&lt;strong&gt;Univeral Links&lt;/strong&gt;的域名和&lt;strong&gt;apple-app-site-association&lt;/strong&gt;文件中的域名不一致，都可能导致无法跳转。我们需要让APP重新下载配置文件，可以尝试删除APP并重启手机。&lt;/p&gt;
&lt;hr&gt;
&lt;div id=&#34;总结&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;总结 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e6%80%bb%e7%bb%93&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;总的来说，对接微信登录并不复杂，主要麻烦在于开放平台的资质认证和应用认证都分别需要审核时间。另外网上有关&lt;strong&gt;Univeral Links&lt;/strong&gt;的配置资料不少，但都不详细，导致笔记最后还是一步步踩坑才调通。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/img/wc-search.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>开发日记 —— 快速对接微信支付</title>
      <link>https://vastzh.com/blog/wechat_pay/</link>
      <pubDate>Mon, 29 Jan 2024 09:38:15 +0800</pubDate>
      
      <guid>https://vastzh.com/blog/wechat_pay/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;最近准备开拓国内的安卓市场，由于安卓厂商不同于苹果，每个厂商都有自己的一套钱包体系同时也为被广大用户所熟知，所以对接微信支付就成为了最通用的选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对接微信支付的条件比较苛刻，其中最大的坎是需要企业资质，包括现在很多广告商也是。&lt;/p&gt;
&lt;p&gt;我见过有些开发者由于没有企业资质，使用支付宝或微信转账。在客户端做一个兑换码的窗口。用户转账后会获得兑换码，使用兑换码在APP中兑换商品。虽然体验不好但确实也解决了这个问题。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;说下具体需要的条件。进入&lt;strong&gt;微信开放平台&lt;/strong&gt;（https://open.weixin.qq.com/），在账号中心填写企业相关信息并进行认证。另外还需要开通 &lt;strong&gt;微信开发者资质&lt;/strong&gt; 认证，这两个认证都需要时间进行审核，建议提前完成。&lt;/p&gt;
&lt;p&gt;之后我们在管理中心创建一个与你的APP对应的移动应用，这里需要填写应用的官网地址，如果没有开发APP官网的需要开发一个，&lt;strong&gt;Docusaurus&lt;/strong&gt; 是不错的选择。完成创建后同样需要等待审核。&lt;/p&gt;
&lt;p&gt;接下来在移动应用的能力专区中开启微信支付，需要注册一个微信支付的商户号通用需要审核时间，对接微信支付的代码会用到此商户号。





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/wechat_pay/image.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;完成上述的准备工作后就可以开始对接微信支付了，先看下微信支付的流程图及接口文档：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微信支付APP接入官方文档&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pay.weixin.qq.com/static/applyment_guide/applyment_detail_app.shtml&#34;   target=&#34;_blank&#34;&gt;
    https://pay.weixin.qq.com/static/applyment_guide/applyment_detail_app.shtml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_5_0.shtml&#34;   target=&#34;_blank&#34;&gt;
    https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_5_0.shtml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里关键是设置&lt;strong&gt;APIv3密钥&lt;/strong&gt;及&lt;strong&gt;申请API证书&lt;/strong&gt;，有了这些资源就可以进行对接了，我使用的是&lt;strong&gt;Flutter&lt;/strong&gt;，所以这里只介绍Flutter的对接方式。&lt;/p&gt;
&lt;p&gt;我在客户端使用 &lt;strong&gt;fluwx&lt;/strong&gt; 插件，使用此插件可以非常方便的接入微信支付。
服务端我是用golang写的 &lt;strong&gt;go-pay&lt;/strong&gt; 库。&lt;/p&gt;
&lt;p&gt;地址如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/OpenFlutter/fluwx&#34;   target=&#34;_blank&#34;&gt;
    https://github.com/OpenFlutter/fluwx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/go-pay&#34;   target=&#34;_blank&#34;&gt;
    https://github.com/go-pay&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实流程比较简单，但是这两个库的文档没有进行描述，可能因为微信支付是挺常规的功能吧。但是对于新手来说，还是需要花点时间。
流程可以参考下图：





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/wechat_pay/image-3.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;简单说，就是先通过服务端进行预下单 通过 你的商户配置 以及 &lt;strong&gt;go-pay&lt;/strong&gt; 按照加密规则 生成一些参数返回客户端，然后客户端使用这些参数 调用 &lt;strong&gt;fluwx&lt;/strong&gt; 的方法，可以让APP跳转到微信支付页进行付款。&lt;/p&gt;
&lt;p&gt;之后通过服务端的支付通知接口回调，进行订单支付验证。最后客户端付款成功后，通过接口向服务端获取商品数据。&lt;/p&gt;
&lt;p&gt;APP下单API:
&lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_2_1.shtml&#34;   target=&#34;_blank&#34;&gt;
    https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_2_1.shtml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;支付通知API:
&lt;a href=&#34;https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_2_5.shtml&#34;   target=&#34;_blank&#34;&gt;
    https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_2_5.shtml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微信付款和支付接口调用是异步的，所以我们需要做到接口加密，否则受到中间人攻击劫持就损害利益了。&lt;/strong&gt;
我采用对请求参数返回结果进行 AES 加密，这样数据即使被劫持也无法进行修改。&lt;/p&gt;
&lt;div id=&#34;总结&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;总结 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e6%80%bb%e7%bb%93&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;本文主要讨论了微信支付的整体流程，有些细节并没有进行描述。比如：下单的时需要传用户标识商品标识，周期性商品如何校验等等。这些同样也比较重要，需要开发者根据具体情况进行开发与配置。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/img/wc-search.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>开发日记 —— 苹果支付指南</title>
      <link>https://vastzh.com/blog/apple_pay/</link>
      <pubDate>Fri, 26 Jan 2024 10:38:15 +0800</pubDate>
      
      <guid>https://vastzh.com/blog/apple_pay/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;上一篇文章分享了实践 Apple 登录的开发过程。 今天主要分享一下 Apple 支付的实践。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div id=&#34;前言&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;前言 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%89%8d%e8%a8%80&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;本次实践中，笔者采用了 &lt;strong&gt;订阅 + 一次性付费&lt;/strong&gt; 的模式。用户可根据自己的需求，选择会员订阅周期。从大部分开发者角度来说，订阅模式是比较常见的，因为订阅更有力于APP的长期发展。&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_pay/p1.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;hr&gt;
&lt;div id=&#34;购买项配置&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;购买项配置 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e8%b4%ad%e4%b9%b0%e9%a1%b9%e9%85%8d%e7%bd%ae&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;进入 开发者后台配置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;strong&gt;App 内购买项目&lt;/strong&gt; 中创建 &lt;strong&gt;永久会员&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;strong&gt;订阅&lt;/strong&gt; 创建订阅组，后分别 &lt;strong&gt;月度会员&lt;/strong&gt; &lt;strong&gt;年度会员&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_pay/p2.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;需要注意两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建的购买项需要设置多语言，否则会出现报错 &lt;strong&gt;缺少元数据&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;审核信息的截图有设备&lt;strong&gt;尺寸限制&lt;/strong&gt;，可参考官方文档：&lt;code&gt;https://developer.apple.com/help/app-store-connect/reference/screenshot-specifications&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div id=&#34;客户端&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;客户端 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%ae%a2%e6%88%b7%e7%ab%af&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;我使用 &lt;strong&gt;in_app_purchase&lt;/strong&gt; 插件，在客户端进行支付。可以运行插件的example进行测试。成功运行效果如下：





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_pay/p3.gif&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;具体细节可以参考插件文档，需要注意的是，我们需要如何进行iOS订单的验证。
通过插件的demo我们看到默认返回true，所以这部分逻辑需要开发者自己实现。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  Future&amp;lt;bool&amp;gt; _verifyPurchase(PurchaseDetails purchaseDetails) async {
    // IMPORTANT!! Always verify a purchase before delivering the product.
    // For the purpose of an example, we directly return true.
    
    return Future&amp;lt;bool&amp;gt;.value(true);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过方法返回的类型可以得到：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class PurchaseVerificationData {
  /// ...

  /// The data used for local verification.
  ///
  /// The data is formatted according to the specifications of the respective
  /// store. You can use the [source] field to determine the store from which
  /// the data originated and proces the data accordingly.
  final String localVerificationData;

  /// The data used for server verification.
  final String serverVerificationData;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们看到 &lt;strong&gt;localVerificationData&lt;/strong&gt; 用于本地验证，&lt;strong&gt;serverVerificationData&lt;/strong&gt; 用于服务器验证。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
    final verificationData =
        purchaseDetails.verificationData.serverVerificationData;

    final Dio dio = Dio();
    dio.options.headers[&amp;#39;Accept&amp;#39;] = &amp;#39;application/json&amp;#39;;
    dio.options.headers[&amp;#39;Content-Type&amp;#39;] = &amp;#39;application/json&amp;#39;;
    var response = await dio.post(&amp;#39;https://buy.itunes.apple.com/verifyReceipt&amp;#39;,
        data: {
          &amp;#39;password&amp;#39;: password,
          &amp;#39;receipt-data&amp;#39;: verificationData
        });
    var _response = json.decode(response.toString());
    if (_response[&amp;#34;status&amp;#34;] == 21007) {
      var response = await dio
          .post(&amp;#39;https://sandbox.itunes.apple.com/verifyReceipt&amp;#39;, data: {
        &amp;#39;password&amp;#39;: password,
        &amp;#39;receipt-data&amp;#39;: verificationData
      });
    }
    if (_response[&amp;#34;status&amp;#34;] == 0) {
      return Future&amp;lt;bool&amp;gt;.value(true);
    } else {
      return Future&amp;lt;bool&amp;gt;.value(false);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;以前苹果提供了一个验证接口，可以跳过服务端进行验证，可惜在去年5月份被标记 &lt;code&gt;Deprecated(已弃用)&lt;/code&gt;，虽然目前看来还是可以使用，但是保不齐哪天就被苹果给删掉了。&lt;/strong&gt;





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_pay/p4.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;通过文档我们得知：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该接口已弃用。要验证服务器上的收据，请按照在服务器上的设备上验证收据中的步骤操作。要在不使用收据的情况下验证服务器上的应用内购买，请调用App Store Server API为您的客户获取 Apple 签名的交易和订阅信息，或验证您的应用获取的签名数据。您还可以从App Store Server Notifications V2端点获取相同的签名交易和订阅信息 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以需要改用 &lt;strong&gt;App Store Server API&lt;/strong&gt; 进行验证。&lt;/p&gt;
&lt;div id=&#34;获取交易信息&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h3 class=&#34;relative group&#34;&gt;获取交易信息 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e8%8e%b7%e5%8f%96%e4%ba%a4%e6%98%93%e4%bf%a1%e6%81%af&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;https://developer.apple.com/documentation/appstoreserverapi/get_transaction_info&lt;/code&gt;
根据文档的描述，我们得知此接口我们可以获取 &lt;strong&gt;包含签名的单个交易信息的结果&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;接着，通过苹果开发后台进行配置下载 &lt;strong&gt;私钥匙文件 + KeyID + BundleID + Issuer&lt;/strong&gt; 进行验签比对订单号等数据判断交易是否成功。&lt;/p&gt;
&lt;div id=&#34;获取历史交易信息&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h3 class=&#34;relative group&#34;&gt;获取历史交易信息 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e8%8e%b7%e5%8f%96%e5%8e%86%e5%8f%b2%e4%ba%a4%e6%98%93%e4%bf%a1%e6%81%af&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;https://developer.apple.com/documentation/appstoreserverapi/get_transaction_history&lt;/code&gt;
根据此接口我们可以获取&lt;strong&gt;包含签名的多个交易信息的结果&lt;/strong&gt;，同样验签后获取详细数据。&lt;/p&gt;
&lt;p&gt;我们可以通过此接口进行订阅到期续费情况等数据进行判断。&lt;/p&gt;
&lt;hr&gt;
&lt;div id=&#34;验签及api配置&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;验签及API配置 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e9%aa%8c%e7%ad%be%e5%8f%8aapi%e9%85%8d%e7%bd%ae&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;在此页面我们可以获取验签需要的数据 &lt;strong&gt;私钥匙文件、 KeyID + BundleID + Issuer&lt;/strong&gt;





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_pay/p5.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;创建沙盒账号后可进行购买订阅的测试，不会收取费用。





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_pay/p6.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;hr&gt;
&lt;div id=&#34;内购被拒&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;内购被拒 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%86%85%e8%b4%ad%e8%a2%ab%e6%8b%92&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;另外，在完成所有工作发布可能会被拒，因为我之前没有订阅经验，所以遇到了一些问题。





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_pay/p7.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;如果做了订阅我建议你完成以下步骤，如果这些步骤都做到了，那么大概率是不会被拒的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在付费页面提供隐私政策及使用条款的入口。&lt;/li&gt;
&lt;li&gt;在使用条款中明确说明和介绍你的订阅服务，包含的服务内容、订阅周期、退订、取消订阅等信息。&lt;/li&gt;
&lt;li&gt;在APP详情页中，提供订阅服务的详细说明。&lt;/li&gt;
&lt;li&gt;提供恢复购买的功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果还是不知道如何做，可以参考一些其他的APP，一般在他们的App详情页和使用条款中都有订阅相关的说明。&lt;/p&gt;
&lt;hr&gt;
&lt;div id=&#34;总结&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;总结 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e6%80%bb%e7%bb%93&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;理论上来说，&lt;strong&gt;获取交易信息&lt;/strong&gt; &lt;strong&gt;获取历史交易信息&lt;/strong&gt; 这两个接口的数据都可以放在客户端本地调用，只是验证这一步放在服务端去做比较符合逻辑。&lt;/p&gt;
&lt;p&gt;无论是全部交易接口在服务端还是验签在服务端，都可能被&lt;strong&gt;劫持&lt;/strong&gt;，即在返回客户端前，对数据进行加工处理，比如修改交易状态来欺瞒客户端。&lt;/p&gt;
&lt;p&gt;所以，最好是对接口数据进行加密。我采用对请求参数返回结构进行 &lt;strong&gt;AES&lt;/strong&gt; 加密，及时数据被劫持也无法进行修改。&lt;/p&gt;
&lt;p&gt;如果没有服务端，极端的方式是把验签放在客户端进行能跑通，因安全性问题不推荐这么做。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/img/wc-search.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>开发日记 —— 记录对接苹果登录的坑</title>
      <link>https://vastzh.com/blog/apple_login/</link>
      <pubDate>Thu, 25 Jan 2024 15:38:15 +0800</pubDate>
      
      <guid>https://vastzh.com/blog/apple_login/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;最近在开发新项目时用到了 苹果登录、微信登录和订阅支付，由于是第一次对接以上内容，踩了不少坑，记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要介绍苹果登录，我也会在之后的文章中介绍微信登录和订阅支付。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div id=&#34;前言&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;前言 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%89%8d%e8%a8%80&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;之前我的APP中大多数是买断式的，用户可以使用一些基本的功能，如果需要高级功能，则需要付费买断。&lt;/p&gt;
&lt;p&gt;这次介于新的项目的特点，我决定在买断的基础之外加上订阅支付，对我来说算是一种新的尝试吧。有了订阅同时也就意味着需要构建一个用户体系来管理订阅。&lt;/p&gt;
&lt;p&gt;对于订阅支付来说&lt;strong&gt;用户体系&lt;/strong&gt;更符合逻辑。但在调研过程中也发现有些APP没有做登录(用户体系)也依然有订阅支付，其主要还是依靠大部分IAP组件提供的&lt;strong&gt;恢复购买&lt;/strong&gt;功能+&lt;strong&gt;本地验证&lt;/strong&gt;接口实现的。但是这里面还是有一些坑，在下文会介绍。&lt;/p&gt;
&lt;hr&gt;
&lt;div id=&#34;正文&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;正文 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e6%ad%a3%e6%96%87&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;先看下完整的苹果登录流程：





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_login/image-3.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;hr&gt;
&lt;div id=&#34;1-苹果开发者后台配置&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h3 class=&#34;relative group&#34;&gt;1. 苹果开发者后台配置 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#1-%e8%8b%b9%e6%9e%9c%e5%bc%80%e5%8f%91%e8%80%85%e5%90%8e%e5%8f%b0%e9%85%8d%e7%bd%ae&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h3&gt;
&lt;p&gt;服务端需要的参数,可在苹果开发者后台设置。 设置App ID, 在 &lt;strong&gt;Capabilities&lt;/strong&gt; 中设置 &lt;strong&gt;Sign In with Apple&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_login/a1.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  







  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_login/a2.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;创建一个用来在服务端与Apple服务器交互的Key，并下载密钥文件。





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_login/a3.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  







  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_login/a4.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;hr&gt;
&lt;div id=&#34;2-客户端配置&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h3 class=&#34;relative group&#34;&gt;2. 客户端配置 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#2-%e5%ae%a2%e6%88%b7%e7%ab%af%e9%85%8d%e7%bd%ae&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h3&gt;
&lt;p&gt;选择主流的Apple登录插件&lt;a href=&#34;https://pub.dev/packages/sign_in_with_apple&#34;   target=&#34;_blank&#34;&gt;
    Sign_in_with_apple&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_login/image.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;dependencies:
  flutter:
    sdk: flutter
  sign_in_with_apple: ^latest_version
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在登录按钮里调用方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;final credential = await SignInWithApple.getAppleIDCredential(
                    scopes: [
                      AppleIDAuthorizationScopes.email,
                      AppleIDAuthorizationScopes.fullName,
                    ],
                  );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;返回结果credential的结构如下源码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/// Authorization details from a successful Sign in with Apple flow.
///
/// Most fields are optional in this class.
///
/// Especially [givenName], [familyName], and [email] member will only be provided on the first authorization between
/// the app and Apple ID.
///
/// The [authorizationCode] member is always present and should be used to check the authorizations with Apple servers
/// from your backend. Upon successful validation, you should create a session in your system for the current user,
/// or consider her now logged in.
@immutable
class AuthorizationCredentialAppleID {
  /// Creates an instance which contains the result of a successful Sign in with Apple flow.
  const AuthorizationCredentialAppleID({
    // 略...
  });

  // 略...

  /// An identifier associated with the authenticated user.
  ///
  /// This will always be provided on iOS and macOS systems. On Android, however, this will not be present.
  /// This will stay the same between sign ins, until the user deauthorizes your App.
  final String? userIdentifier;
 
  /// The verification code for the current authorization.
  ///
  /// This code should be used by your server component to validate the authorization with Apple within 5 minutes upon receiving it.
  final String authorizationCode;

  /// A JSON Web Token (JWT) that securely communicates information about the user to your app.
  final String? identityToken;

  // 略...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们主要用到的是这样几个字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;userIdentifier&lt;/code&gt;            —— 苹果用户的唯一标识&lt;/li&gt;
&lt;li&gt;&lt;code&gt;identityToken&lt;/code&gt;             —— jwt加密的idToken,可以在通过接口获取出上面的userIdentifier&lt;/li&gt;
&lt;li&gt;&lt;code&gt;authorizationCode&lt;/code&gt;         —— 配合secret，keyId，teamId，clientId可以获取到jwt加密的idToken&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PS: &lt;strong&gt;userIdentifier&lt;/strong&gt; 是用户唯一标识, 如果没有服务端则可以通过 &lt;strong&gt;userIdentifier&lt;/strong&gt; 直接使用但不推荐。正确安全的方式通过服务端获取，就可以用第二或第三个字段。
服务端代码可参考这里：&lt;a href=&#34;https://github.com/Timothylock/go-signin-with-apple/tree/master&#34;   target=&#34;_blank&#34;&gt;
    go-signin-with-apple&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;div id=&#34;3-xcode配置&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h3 class=&#34;relative group&#34;&gt;3. XCode配置 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#3-xcode%e9%85%8d%e7%bd%ae&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h3&gt;
&lt;p&gt;打开ios目录，在Runner（文件浏览器侧栏）-&amp;gt; Targets-&amp;gt; Runner-&amp;gt;Signing &amp;amp; Capabilities设置 Apple Developer Portal 中创建的“Bundle Identifier”





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_login/image-1.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;确保应用具有“使用 Apple 登录”功能（Runner（文件浏览器侧边栏）-&amp;gt; Targets-&amp;gt; Runner-&amp;gt; Signing &amp;amp; Capabilities），否则使用 Apple 登录将失败且没有视觉指示（代码仍会收到异常） ）





  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/apple_login/image-2.png&#34;
        alt=&#34;Alt text&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;hr&gt;
&lt;div id=&#34;4-服务端验证&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h3 class=&#34;relative group&#34;&gt;4. 服务端验证 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#4-%e6%9c%8d%e5%8a%a1%e7%ab%af%e9%aa%8c%e8%af%81&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h3&gt;
&lt;p&gt;通过 &lt;strong&gt;authorizationCode&lt;/strong&gt; 获取 &lt;strong&gt;userIdentifier&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import &amp;#34;github.com/Timothylock/go-signin-with-apple/apple&amp;#34;

client := apple.New()

vReq := apple.AppValidationTokenRequest{
	ClientID:     clientID,
	ClientSecret: secret,
	Code:         &amp;#34;authorizationCode&amp;#34;, // 客户端获取的 authorizationCode
}

var resp apple.ValidationResponse

// Do the verification
client.VerifyAppToken(context.Background(), vReq, &amp;amp;resp)

unique, _ := apple.GetUniqueID(resp.IDToken)

// Voila!
fmt.Println(unique)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 &lt;strong&gt;identityToken&lt;/strong&gt; 获取 &lt;strong&gt;userIdentifier&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;unique, _ := apple.GetUniqueID(params.IDToken)

claim, _ := apple.GetClaims(params.IDToken)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解析后，&lt;code&gt;claim[&amp;quot;sub&amp;quot;]&lt;/code&gt;是userIdentifier, &lt;code&gt;claim[aud]&lt;/code&gt;是BundleID。&lt;/p&gt;
&lt;p&gt;最后，将userIdentifier和token保存到数据库中，以上是苹果登录的配置和流程。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/img/wc-search.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>出海日记——单机版应用如何做数据同步</title>
      <link>https://vastzh.com/blog/local_sync/</link>
      <pubDate>Tue, 21 Nov 2023 16:22:12 +0800</pubDate>
      
      <guid>https://vastzh.com/blog/local_sync/</guid>
      <description>&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/local_sync/sync.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;br&gt;
如果你是刚入门  &lt;strong&gt;独立开发&lt;/strong&gt;  ，你可能有过这样的思考，我做的APP会不会有人用？  刚开始会不会有盈利？  有没有必要把数据保存在服务端？&lt;br&gt;
&lt;br&gt;
其实在一切条件都允许的情况，我认为一个应用必然  &lt;strong&gt;要有一个服务器&lt;/strong&gt;的，有了服务器，用户的数据更安全不会因为更新卸载应用而导致数据丢失，同时也方便开发者通过观察用户数据去更新和迭代应用。也能更好的对应用进行控制，如权限，公告，内购的折扣等等。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;当然，服务器也会带来很多&lt;strong&gt;额外的成本&lt;/strong&gt;，比如运维，安全，服务器费用，接口开发等等。你需要考虑服务器的配置，一般双11各大云厂商都有2~5折优惠，但是&lt;strong&gt;续费&lt;/strong&gt;时吓死人，同时你可能也要考虑避免服务器被攻击等问题。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;以我个人为例，开发了10来个工具类的应用。有时候为了更好的增加用户粘性，也会增加像打卡签到，用户日常数据的记录。有趣的是，我的这些应用都没有接服务器，原因就像上面所说。刚开始我更希望的是，APP开发完成了，就&lt;strong&gt;不再需要额外的维护成本&lt;/strong&gt;，除非我想加新的功能。这样我才有更多时间去专注下一个APP，  虽然干了9年后端，前期还是不想有额外的负担。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;进入正题，如果你和我想法一样，那么单机版应用要如何做数据同步？答案是，做云同步或者说类似于用用户自己的网盘去同步。接下来说一下我的&lt;br&gt;
&lt;strong&gt;Flutter方案&lt;/strong&gt;。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;目前我的APP都发布在  &lt;strong&gt;Google Play&lt;/strong&gt;，所以这里也是举例海外的一套方案，你完全可以照葫芦画瓢开发一套适应国内的方案。不过我建议如果你想针对你的某个APP发力做精品还是接个服务器会比较好。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Google  OAuth + Drive&lt;/strong&gt;这是一套谷歌方案，你可能常常看到国外的APP上看到同步的功能，一般先登录谷歌账号，之后定期自动同步。虽然不清楚老外怎么实现的，用没用上服务器。但是我自己摸索的这套方案，也能做到同样的效果，也不需要维护服务器。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;可能有人会有疑问，Drive只是一个网盘怎么备份应用的数据。其实方法也不难，一般工具类APP，即使记录了一年的用户数据，数据量也是非常小的。可以写一个工具类把数据转成json存储到文件里，再写个方法把json解析成数据对象回写到你的存储引擎。或者更省事，你可以使用&lt;strong&gt;sqlite&lt;/strong&gt;，直接把整个sql文件给上传了。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;div id=&#34;步骤&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;步骤 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e6%ad%a5%e9%aa%a4&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;p&gt;打开  &lt;strong&gt;Google Cloud Platform API manager&lt;/strong&gt; [https://console.cloud.google.com/apis/dashboard]，点击启用API和服务&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/local_sync/8b1bddb0d675fed1c4277d608808b9ec.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;搜索drive关键期，选择Google Drive API添加&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/local_sync/ba056a9dfc6439867397fdfc7a23e271.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;添加API凭据，这里我是通过&lt;br&gt;
&lt;strong&gt;Firebase&lt;/strong&gt;自动生成。&lt;/p&gt;
&lt;p&gt;所以也可以去&lt;br&gt;
&lt;strong&gt;Firebase&lt;/strong&gt;中创建项目（之后我会写篇Firebase如何创建项目的文章）&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/local_sync/b76c4a5d42c4fec09eccea3204669e3b.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;创建完项目和应用后，需要在Authentication模块中加入登入验证方式。&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/local_sync/004d79734dda2917deeb4c846b7073dc.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;要求填入Oauth客户端ID&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/local_sync/29cbaafaffadc6a41ac6b06fba941d27.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;这是可以返回刚才Google Cloud Platform API manager [https://console.cloud.google.com/apis/dashboard]，已经自动创建的Oauth客户端信息复制ID和密钥。&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/local_sync/dc18d14a6e273b625d7d900bc931a1fd.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;到这，配置就差不多了，来看下主要代码&lt;/p&gt;
&lt;p&gt;在pubspec.yaml中添加依赖：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  google_sign_in: ^6.1.4
  googleapis: ^11.2.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建用来登录的变量&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  import &amp;#39;package:googleapis/drive/v3.dart&amp;#39; as drive;
  import &amp;#39;package:google_sign_in/google_sign_in.dart&amp;#39;;
  
  GoogleSignInAccount? account;
  ...
  // 调用此方法可以让APP出现登入弹窗
  account = await GoogleSignIn.standard(scopes: [drive.DriveApi.driveScope])
          .signIn();
          
  // 注销登入  
  await GoogleSignIn.standard(scopes: [
                                drive.DriveApi.driveScope
                                    ]).signOut();      
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据自己的业务逻辑使用登入登出功能。&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/local_sync/beb972b89ca12cc63a94404659035286.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;到这里我们拿到了用于调用drive接口所需的验签。&lt;/p&gt;
&lt;p&gt;再来看一下drive上传和下载的方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import &amp;#39;package:googleapis/drive/v3.dart&amp;#39; as drive;


 // 获取driveApiClient
 final driveApi =
          drive.DriveApi(GoogleAuthClient(await account!.authHeaders));
 
 
 // 上传db文件
 final dbMedia =
    drive.Media(File(dbPath).openRead(), File(dbPath).lengthSync());
 final file = drive.File()
   ..name = dbPath.split(&amp;#39;/&amp;#39;).last
   ..parents = [parentFolderId]
   ..description = dbVersion.toString(); 
 await driveApi.files.create(file, uploadMedia: dbMedia);

 // 下载本地更新
 final dbMedia = await driveApi.files.get(dbFileId,
              downloadOptions: drive.DownloadOptions.fullMedia) as drive.Media;
  List&amp;lt;int&amp;gt; contentBytes = [];
  await dbMedia.stream.listen((bytes) {
    contentBytes.addAll(bytes);
  }).asFuture();
  await File(dbPath).writeAsBytes(contentBytes, flush: true);
  Logger().i(&amp;#39;本地更新&amp;#39;);
 
 
          
 // 封装一个带验签的http client
 class GoogleAuthClient extends BaseClient {
  final Map&amp;lt;String, String&amp;gt; headers;
  final Client client = Client();

  GoogleAuthClient(this.headers);

  @override
  Future&amp;lt;StreamedResponse&amp;gt; send(BaseRequest request) {
    return client.send(request..headers.addAll(headers));
  }
}         
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里只演示如何上传和下载，同步逻辑请根据自身需要来实现。&lt;/p&gt;
&lt;p&gt;如果你是&lt;br&gt;
&lt;strong&gt;安卓开发&lt;/strong&gt;，那么需要使用Android对应的SDK即可，配置应该都是一样的。&lt;/p&gt;
&lt;p&gt;强调一下，我在使用sqlite的时候，其实使用了&lt;strong&gt;多个db文件&lt;/strong&gt;。原因是我不希望所有的数据都需要同步。例如下次我们开发了一个新的功能，在数据库中增加了新字段B来控制或记录这个功能。这是如果用全套db同步的方案，B字段会因为同步而消失从而导致问题。&lt;/p&gt;
&lt;p&gt;不是所有的数据都需要同步备份，精简出业务所需的用户功能数据来进行备份，这样才能减少问题。&lt;strong&gt;所以具体怎么同步根据不同的需求去设计。&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&#34;引用&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h2 class=&#34;relative group&#34;&gt;引用 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%bc%95%e7%94%a8&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://pub.dev/packages/google_sign_in
https://pub.dev/packages/googleapis
https://cloud.google.com/docs/authentication?hl=zh_CN&amp;amp;_ga=2.156109883.-1604196893.1667810752
https://firebase.google.com/docs/flutter/setup?hl=zh-cn&amp;amp;platform=android
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;!-- &lt;img src=&#34;../../../img/wc-search.png&#34; alt=&#34;公众号&#34; style=&#34;width:80%; display:block; margin:auto;&#34;&gt; --&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/img/wc-search.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>出海日记——Admob完成这个操作否则明年可能没有广告收入</title>
      <link>https://vastzh.com/blog/gdpr_message/</link>
      <pubDate>Wed, 15 Nov 2023 16:22:12 +0800</pubDate>
      
      <guid>https://vastzh.com/blog/gdpr_message/</guid>
      <description>&lt;p&gt;出海的第N天，打开手机想看下昨天Admob的广告收入，打开网页弹出了一个大大的框遮挡了一切，画风完全不同。&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/gdpr_message/e1b700e64936af3f230523186c9c9d77.jpeg&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定眼一看&lt;/strong&gt;&lt;br&gt;
原来是要我&lt;strong&gt;创建GDPR用户意见征求&lt;/strong&gt;的消息。其实GDPR的提示框，在几个月前，就在电脑网页版的admob最上方显示。当时问了一些朋友，说是没什么影响&lt;br&gt;
可以放一放。毕竟要&lt;strong&gt;2024年1月16生效&lt;/strong&gt;  。&lt;/p&gt;
&lt;p&gt;以前手机访问没有这个框，直接看看收入就完事了。现在每次打开网页必须选择其中一项什么也看不到了，当时也不知道这些选项什么意思会不会踩坑，迫于无奈只能把GDPR这件事提前折腾了。&lt;/p&gt;
&lt;div id=&#34;什么是gdpr&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h3 class=&#34;relative group&#34;&gt;什么是GDPR 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afgdpr&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;2018 年 5 月 25 日生效的《通用数据保护条例》(GDPR) 是一项全面的数据隐私法律，为个人数据的收集、处理、存储和传输建立了一个框架。它要求以安全的方式处理所有个人数据，并包括对不遵守这些要求的企业的罚款和处罚。它还为个人提供了一些有关其个人数据的权利。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的理解是个性化广告会通过Cookie收集用户的个人数据，在使用广告类SDK时，如Admob，也会收集用户的信息。在&lt;strong&gt;欧洲经济区和英国境内&lt;/strong&gt;&lt;br&gt;
的用户就需要向用户征求意见。&lt;/p&gt;
&lt;p&gt;创建GDPR消息，也就是在APP打开时弹出对话框，告知用户APP的隐私政策以及应用中的个性化广告会获取用户数据，用户可以选择同意或不同意。&lt;/p&gt;
&lt;div id=&#34;具体步骤&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h3 class=&#34;relative group&#34;&gt;具体步骤 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%85%b7%e4%bd%93%e6%ad%a5%e9%aa%a4&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h3&gt;
&lt;p&gt;1.点击&lt;strong&gt;开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/gdpr_message/e2b885f4388b83c32bafaa6029582c49.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;2.选择要&lt;strong&gt;创建GDPR消息&lt;/strong&gt;的应用，并设置&lt;strong&gt;用户选项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/gdpr_message/dcd70a8e84445b667617bd33026c7e29.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;3.设置&lt;strong&gt;隐私政策网址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/gdpr_message/5594a1087b526d1fab24d71c31d3776c.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;4.在应用中设置&lt;strong&gt;GDPR消息弹出的代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在代码最初的initState中加入代码：****&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; final params = ConsentRequestParameters(
      consentDebugSettings: debugSettings,
    );
    ConsentInformation.instance.requestConsentInfoUpdate(
      params,
      () async {
        if (await ConsentInformation.instance.isConsentFormAvailable()) {
          loadForm();
        }
      },
      (FormError error) {
        // Handle the error
      },
    );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;‍&lt;/p&gt;
&lt;p&gt;要呈现同意书，请使用类&lt;strong&gt;show()&lt;/strong&gt;&lt;br&gt;
上的方法&lt;strong&gt;ConsentForm&lt;/strong&gt;&lt;br&gt;
。&lt;br&gt;
必须在提交表格之前确定用户是否需要同意。要检查是否需要同意，请调用getConsentStatus()&lt;br&gt;
该 ConsentInformation&lt;br&gt;
对象，该对象返回类型为 的枚举ConsentStatus&lt;br&gt;
。有四个可能的值ConsentStatus&lt;br&gt;
：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;unknown&lt;/strong&gt;&lt;br&gt;
：未知的同意状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;required&lt;/strong&gt;&lt;br&gt;
：需要但尚未获得用户同意。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;notRequired&lt;/strong&gt;&lt;br&gt;
：不需要用户同意。例如，用户不在欧洲经济区或英国。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;obtained&lt;/strong&gt;&lt;br&gt;
：已获得用户同意。个性化未定义。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;loadForm&lt;br&gt;
像这样改变你的方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  void loadForm() {
    ConsentForm.loadConsentForm(
      (ConsentForm consentForm) async {
        var status = await ConsentInformation.instance.getConsentStatus();
        // 在不同的状态下写各自的逻辑。
        if (status == ConsentStatus.required) {
          consentForm.show(
            (FormError? formError) {
              // 呈现同意书
              loadForm();
            },
          );
        } else if (status == ConsentStatus.obtained) {
            // 添加同意后的逻辑
        }
      },
      (formError) {
          // 错误处理
      },
    );
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.本地调试&lt;/p&gt;
&lt;p&gt;如何你设置的GDPR消息只对欧盟地区弹出消息框，则可以&lt;strong&gt;强制地理&lt;/strong&gt;&lt;br&gt;
进行调试。&lt;/p&gt;
&lt;p&gt;增加如下代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ConsentDebugSettings debugSettings = ConsentDebugSettings(
  debugGeography: DebugGeography.debugGeographyEea,
  testIdentifiers: [&amp;#39;TEST-DEVICE-HASHED-ID&amp;#39;]);

ConsentRequestParameters params = ConsentRequestParameters(
  consentDebugSettings: debugSettings);
  
// 省略后面内容
  ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;应用程序的调试设置中提供测试设备的哈希 ID 才能使用调试功能，用ID来代替&lt;strong&gt;TEST-DEVICE-HASHED-ID&lt;/strong&gt;&lt;br&gt;
内容。&lt;/p&gt;
&lt;p&gt;如果你之前的项目已经集成了Admob，则在调试运行的日志中&lt;strong&gt;搜索关键字&lt;/strong&gt;就可以看到&lt;strong&gt;测试设备的哈希 ID&lt;/strong&gt;&lt;br&gt;
。如下图：&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/gdpr_message/b501f534a30e0a581505cc70c0360c75.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;p&gt;最后，热更新一下应用就可以呈现&lt;strong&gt;GDPR弹窗&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/blog/gdpr_message/bb61ccec215743bc2b246968927f7048.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
&lt;div id=&#34;最后附上参考资料&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h3 class=&#34;relative group&#34;&gt;最后附上参考资料 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e6%9c%80%e5%90%8e%e9%99%84%e4%b8%8a%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h3&gt;
&lt;div id=&#34;创建gdpr消息文档地址如下&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h4 class=&#34;relative group&#34;&gt;创建GDPR消息文档地址如下： 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#%e5%88%9b%e5%bb%bagdpr%e6%b6%88%e6%81%af%e6%96%87%e6%a1%a3%e5%9c%b0%e5%9d%80%e5%a6%82%e4%b8%8b&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://support.google.com/admob/answer/10113207?hl=zh-Hans&amp;amp;ref_topic=10105230&amp;amp;sjid=1600386979072872981-AP&#34;   target=&#34;_blank&#34;&gt;
    https://support.google.com/admob/answer/10113207?hl=zh-Hans&amp;ref_topic=10105230&amp;sjid=1600386979072872981-AP&lt;/a&gt;&lt;/p&gt;
&lt;div id=&#34;flutter集成文档&#34; class=&#34;anchor&#34;&gt;&lt;/div&gt;
&lt;h4 class=&#34;relative group&#34;&gt;Flutter集成文档： 
    &lt;span
        class=&#34;absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100&#34;&gt;
        &lt;a class=&#34;group-hover:text-primary-300 dark:group-hover:text-neutral-700&#34;
            style=&#34;text-decoration-line: none !important;&#34; href=&#34;#flutter%e9%9b%86%e6%88%90%e6%96%87%e6%a1%a3&#34; aria-label=&#34;锚点&#34;&gt;#&lt;/a&gt;&lt;/span&gt;        
    
&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://developers.google.cn/admob/flutter/eu-consent?hl=zh-cn&#34;   target=&#34;_blank&#34;&gt;
    https://developers.google.cn/admob/flutter/eu-consent?hl=zh-cn&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;




  
  
    
  
  
    &lt;figure&gt;
      
      &lt;img
        class=&#34;my-0 rounded-md&#34;
        src=&#34;https://vastzh.com/img/wc-search.png&#34;
        alt=&#34;&#34;
      /&gt;
      
      
    &lt;/figure&gt;
  

&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
